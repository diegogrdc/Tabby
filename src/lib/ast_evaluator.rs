// File used to define the evaluator
// of an AST, adding the nerve
// points needed to generate
// intermediate code, store
// directory functions,
// evaluate expressions, etc
use crate::ast;
use crate::dir_func::*;
use crate::dir_var::*;
use crate::quadruples::*;
use crate::semantic_cube::*;
use crate::tipo::*;
use crate::vir_mem::*;
use std::collections::HashMap;

/*
Parameters used in our AST Evaluator
where we generate IC (Intermediate Code)
and check semantics
Params:
- dir_func
    Directory Function, where
    we store important information about functions
    and their variables
- sem_cube
    Semantic cube, generated to check semantic
    operations are correct and used to detect
    type mismatchs
- vir_mem_alloc
    Allocator for virtual memory. It takes care
    of memory logic and addresses used in quadruples
    generation
- st_ops
    Stack used to store operation pending eval
    in IC generation
- st_vals
    Stack used to store values pending eval
    in IC generation
- st_tips
    Stack used to store value types pending eval
    in IC generation
- quads
    List of Quadruples that is generated by the AST
- next_cnt
    Counter to index temp variables used in
    IC Code Generation
- glob_scope
    Optional string with the name of the current
    global scope to fetch fn and global vars names
    and types, to validate their usage
- loc_scope
    Optional string with name of the current local
    scope (function) to fetch local var names and types
    to validate their usage
- curr_fn_size_loc
    List of size 3 used to store current declared variables in
    local context to calculate workspace size
    required in execution
    Represents local vars
- curr_fn_size_tmp
    List of size 3 used to store current created variables in
    local context to calculate workspace size
    required in execution
    Represents temporal variables created and used in ic
- curr_fn_tipo
    Current function type used to determine
    if returns are valid or not
*/
pub struct AstEvaluator {
    pub dir_func: DirFunc,
    pub sem_cube: SemanticCube,
    pub vir_mem_alloc: VirMemAllocator,
    pub st_ops: Vec<String>,
    pub st_vals: Vec<String>,
    pub st_tips: Vec<Tipo>,
    pub quads: Vec<Quadruple>,
    pub next_cnt: i32,
    pub glob_scope: Option<String>,
    pub loc_scope: Option<String>,
    pub curr_fn_size_loc: [i32; 3],
    pub curr_fn_size_tmp: [i32; 3],
    pub curr_fn_tipo: Tipo,
}

// ASTEvaluator Builder
impl AstEvaluator {
    pub fn new() -> AstEvaluator {
        AstEvaluator {
            dir_func: DirFunc::new(),
            sem_cube: SemanticCube::new(),
            vir_mem_alloc: VirMemAllocator::new(),
            st_ops: Vec::new(),
            st_vals: Vec::new(),
            st_tips: Vec::new(),
            quads: Vec::new(),
            next_cnt: 1,
            glob_scope: None,
            loc_scope: None,
            curr_fn_size_loc: [0, 0, 0],
            curr_fn_size_tmp: [0, 0, 0],
            curr_fn_tipo: Tipo::Void,
        }
    }
}

/*
Implementation of AST evaluation and
neuralgic points implementation to
check semantics and generate IC code
*/
impl AstEvaluator {
    pub fn throw_compile_error(&self, msg: String) {
        eprintln!("\nCOMPILE ERROR: {}\n", msg);
        panic!();
    }

    pub fn eval_program(&mut self, program: Box<ast::Program>) -> bool {
        // Push a temporal quadruple that will call a
        // goto into Tabby Function
        self.quads.push(Quadruple::Temp());
        match *program {
            ast::Program::Program(id, vardecs, functions, tabby) => {
                // Set global scope name
                self.glob_scope = Some(id.clone());

                // Generate global directory of vars
                // before adding row to dir func
                // as this cannot be mutated
                // after creation
                // due to borrowing rules
                // and immutable structs in Rust
                let mut glob_vars = DirVar::new();
                self.eval_var_decs(vardecs, &mut glob_vars);

                // Create our "global scope" function in
                // directory of functions, with id name,
                // type void, and an our variable dir
                self.dir_func.insert(
                    id.clone(),
                    FuncInfo {
                        tipo: Tipo::Program,
                        dir_var: glob_vars,
                        pos_init: -1,
                        size_loc: self.curr_fn_size_loc.clone(),
                        size_tmp: [1, 1, 1],
                        params: Vec::new(),
                    },
                );

                self.eval_functions(functions);
                self.eval_tabby(tabby);
            }
        };
        true
    }

    pub fn eval_block(&mut self, block: Box<ast::Block>) -> bool {
        match *block {
            ast::Block::Block(statutes) => {
                self.eval_statutes(statutes);
            }
        };
        true
    }

    pub fn eval_statutes(&mut self, statutes: Box<ast::Statutes>) -> bool {
        match *statutes {
            ast::Statutes::Statutes(statute_vec) => {
                for statute in statute_vec {
                    self.eval_statute(statute);
                }
            }
        };
        true
    }

    pub fn eval_statute(&mut self, statute: Box<ast::Statute>) -> bool {
        match *statute {
            ast::Statute::Assignment(assignment) => {
                self.eval_assignment(assignment);
            }
            ast::Statute::Call(call) => {
                self.eval_call(call);
                // This call adds an extra
                // call element in our stack
                // that we need to delete to avoid
                // garbage accumulating here
                self.st_vals.pop();
                self.st_tips.pop();
            }
            ast::Statute::Read(read) => {
                self.eval_read(read);
            }
            ast::Statute::Print(print) => {
                self.eval_print(print);
            }
            ast::Statute::Return(ret) => {
                self.eval_return(ret);
            }
            ast::Statute::Ciclew(ciclew) => {
                self.eval_ciclew(ciclew);
            }
            ast::Statute::Ciclef(ciclef) => {
                self.eval_ciclef(ciclef);
            }
            ast::Statute::Cond(cond) => {
                self.eval_cond(cond);
            }
        };
        true
    }

    pub fn eval_var_decs(&mut self, vardecs: Box<ast::Vardecs>, vars: &mut DirVar) -> bool {
        match *vardecs {
            ast::Vardecs::Vardecs(vardec_vec) => {
                for vardec in vardec_vec {
                    self.eval_var_dec(vardec, vars);
                }
            }
        };
        true
    }

    pub fn eval_var_dec(&mut self, vardec: Box<ast::Vardec>, vars: &mut DirVar) -> bool {
        match *vardec {
            ast::Vardec::Vars(typ, id_vec) => {
                for id in id_vec {
                    self.check_multiple_dec_var(&id, &vars);
                    vars.insert(
                        id,
                        VarInfo {
                            tipo: tipo_from_type(&typ),
                            addr: self.vir_mem_alloc.get_global_addr(&tipo_from_type(&typ), 1),
                            dim: Dim::Single,
                        },
                    );
                    self.add_loc_var_to_size(&tipo_from_type(&typ), 1);
                }
            }
            ast::Vardec::Arr(typ, id, sz) => {
                self.check_multiple_dec_var(&id, &vars);
                if sz < 1 {
                    self.throw_compile_error(format!("Array size must be greater than 0"));
                }
                vars.insert(
                    id,
                    VarInfo {
                        tipo: tipo_from_type(&typ),
                        addr: self
                            .vir_mem_alloc
                            .get_global_addr(&tipo_from_type(&typ), sz),
                        dim: Dim::Arr(sz),
                    },
                );
                self.add_loc_var_to_size(&tipo_from_type(&typ), sz);
            }
            ast::Vardec::Mat(typ, id, sz1, sz2) => {
                self.check_multiple_dec_var(&id, &vars);
                if sz1 < 1 || sz2 < 1 {
                    self.throw_compile_error(format!(
                        "All Matrix dimension sizes must be greater than 0"
                    ));
                }
                vars.insert(
                    id,
                    VarInfo {
                        tipo: tipo_from_type(&typ),
                        addr: self
                            .vir_mem_alloc
                            .get_global_addr(&tipo_from_type(&typ), sz1 * sz2),
                        dim: Dim::Mat(sz1, sz2),
                    },
                );
                self.add_loc_var_to_size(&tipo_from_type(&typ), sz1 * sz2);
            }
        };
        true
    }

    pub fn eval_functions(&mut self, functions: Box<ast::Functions>) -> bool {
        match *functions {
            ast::Functions::Fns(function_vec) => {
                for function in function_vec {
                    self.reset_fn_params();
                    self.eval_function(function);
                }
            }
        };
        true
    }

    pub fn eval_function(&mut self, function: Box<ast::Function>) -> bool {
        // For any function, we must create its entry on
        // Directory of Functions, and create its local
        // variables (params) in a Directory of Variables
        let mut vars = DirVar::new();
        let fn_id: String;
        let fn_tipo: Tipo;
        let fn_block: Box<ast::Block>;
        let mut param_list: Vec<Tipo> = Vec::new();

        // Eval params when needed and get
        // relevant info like id, type and block
        match *function {
            ast::Function::FnParams(typ, id, params, block) => {
                fn_id = id.clone();
                fn_tipo = tipo_from_type(&typ);
                fn_block = block;

                self.eval_params(params, &mut vars, &mut param_list);
            }
            ast::Function::FnVoidParams(id, params, block) => {
                fn_id = id.clone();
                fn_tipo = Tipo::Void;
                fn_block = block;

                self.eval_params(params, &mut vars, &mut param_list);
            }
            ast::Function::Fn(typ, id, block) => {
                fn_id = id.clone();
                fn_tipo = tipo_from_type(&typ);
                fn_block = block;
            }
            ast::Function::FnVoid(id, block) => {
                fn_id = id.clone();
                fn_tipo = Tipo::Void;
                fn_block = block;
            }
        };

        // Check fn name is unique
        self.check_multiple_dec_fns(&fn_id);
        let pos_init = self.quads.len() as i32;
        // Set current local scope
        self.loc_scope = Some(fn_id.clone());
        // Set current fn type
        self.curr_fn_tipo = fn_tipo.clone();
        // Create local var table
        self.dir_func.insert(
            fn_id.clone(),
            FuncInfo {
                tipo: fn_tipo,
                dir_var: vars,
                pos_init: pos_init,
                size_loc: [0, 0, 0],
                size_tmp: [0, 0, 0],
                params: param_list,
            },
        );
        // Eval fn block
        self.eval_block(fn_block);
        // Insert End Command
        self.quads.push(Quadruple::EndFunc());
        // Add size
        self.set_fn_size(&fn_id);
        // Remove current local scope
        self.loc_scope = None;
        true
    }

    pub fn eval_params(
        &mut self,
        params: Box<ast::Params>,
        vars: &mut DirVar,
        param_list: &mut Vec<Tipo>,
    ) -> bool {
        // Remember arrs and mats are sent as references
        match *params {
            ast::Params::Param(typ, id) => {
                self.add_param(id, tipo_from_type(&typ), vars);
                param_list.push(tipo_from_type(&typ));
            }
            ast::Params::ParamAnd(typ, id, params) => {
                self.add_param(id, tipo_from_type(&typ), vars);
                param_list.push(tipo_from_type(&typ));

                self.eval_params(params, vars, param_list);
            }
        };
        true
    }

    pub fn add_param(&mut self, id: String, tip: Tipo, vars: &mut DirVar) {
        self.check_multiple_dec_var(&id, &vars);
        self.add_loc_var_to_size(&tip, 1);
        vars.insert(
            id,
            VarInfo {
                tipo: tip.clone(),
                addr: self.vir_mem_alloc.get_local_addr(&tip),
                dim: Dim::Single,
            },
        );
    }

    pub fn eval_tabby(&mut self, tabby: Box<ast::Tabby>) -> bool {
        match *tabby {
            ast::Tabby::Tabby(block) => {
                self.reset_fn_params();
                // Change first quad to point here
                self.curr_fn_tipo = Tipo::Void;
                self.quads
                    .insert(0, Quadruple::GoTo(self.quads.len() as i32));
                self.quads.remove(1);
                let pos_init = self.quads.len() as i32;

                // Create local var table
                self.dir_func.insert(
                    "Tabby".to_string(),
                    FuncInfo {
                        tipo: Tipo::Void,
                        dir_var: HashMap::new(),
                        pos_init: pos_init,
                        size_loc: [0, 0, 0],
                        size_tmp: [0, 0, 0],
                        params: Vec::new(),
                    },
                );

                self.eval_block(block);

                // Insert End Command
                self.quads.push(Quadruple::EndFunc());
                self.set_fn_size(&"Tabby".to_string());
            }
        };
        true
    }

    pub fn eval_read(&mut self, read: Box<ast::Read>) -> bool {
        match *read {
            ast::Read::Read(var) => {
                self.eval_variable(var);
                // Create the quadruple for this read
                // and clean info from stacks
                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                let id_addr = self.get_id_addr(&id, &tip);
                self.quads
                    .push(Quadruple::Read("Read".to_string(), id_addr));
            }
        };
        true
    }

    pub fn eval_assignment(&mut self, assignment: Box<ast::Assignment>) -> bool {
        match *assignment {
            ast::Assignment::Assign(var, exp) => {
                self.eval_variable(var);
                // Push operator
                self.st_ops.push("=".to_string());
                // Solve exp
                self.eval_exp(exp);
                // Create quadruple
                assert!(self.st_ops.last().unwrap() == &"=".to_string());
                self.st_ops.pop();
                let rt_val: String = self.st_vals.pop().unwrap();
                let lt_val: String = self.st_vals.pop().unwrap();
                let rt_tipo: Tipo = self.st_tips.pop().unwrap();
                let lt_tipo: Tipo = self.st_tips.pop().unwrap();
                // Get result type to assure no type mismatch
                self.get_result_tipo(&lt_tipo, &rt_tipo, "=");
                let lt_id_addr = self.get_id_addr(&lt_val, &lt_tipo);
                let rt_id_addr = self.get_id_addr(&rt_val, &rt_tipo);
                self.quads
                    .push(Quadruple::Assign("=".to_string(), rt_id_addr, lt_id_addr));
            }
        };
        true
    }

    pub fn eval_print(&mut self, print: Box<ast::Print>) -> bool {
        match *print {
            ast::Print::Print(print_vars) => {
                self.eval_print_vars(print_vars);
            }
        };
        true
    }

    pub fn eval_print_vars(&mut self, print_vars: Box<ast::PrintVars>) -> bool {
        match *print_vars {
            ast::PrintVars::Exp(exp) => {
                self.eval_exp(exp);
                // Print quad after eval
                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                if tip == Tipo::Void {
                    self.throw_compile_error(format!("Can't print a Void type"));
                }
                let id_addr = self.get_id_addr(&id, &tip);
                self.quads
                    .push(Quadruple::Print("Print".to_string(), id_addr));
            }
            ast::PrintVars::StrLit(sl) => {
                // Print string lit
                let id_addr = self.get_id_addr(&format!("\"{}", sl), &Tipo::StrLit);
                self.quads
                    .push(Quadruple::Print("PrintSL".to_string(), id_addr));
            }
            ast::PrintVars::ExpPV(exp, pv) => {
                self.eval_exp(exp);
                // Print quad after eval
                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                if tip == Tipo::Void {
                    self.throw_compile_error(format!("Can't print a Void type"));
                }
                let id_addr = self.get_id_addr(&id, &tip);
                self.quads
                    .push(Quadruple::Print("Print".to_string(), id_addr));
                // Eval others
                self.eval_print_vars(pv);
            }
            ast::PrintVars::StrLitPV(sl, pv) => {
                // Print string lit
                let id_addr = self.get_id_addr(&format!("\"{}", sl), &Tipo::StrLit);
                self.quads
                    .push(Quadruple::Print("PrintSL".to_string(), id_addr));
                self.eval_print_vars(pv);
            }
        };
        true
    }

    pub fn eval_variable(&mut self, variable: Box<ast::Variable>) -> bool {
        match *variable {
            ast::Variable::Id(id) => {
                let tipo = self.get_var_tipo_from_id(&id);
                // Push var to stack
                self.st_vals.push(id);
                self.st_tips.push(tipo);
            }
            ast::Variable::Arr(id, exp) => {
                let (tipo, sz) = self.get_arr_tipo_and_sz_from_id(&id);
                // Get base array position
                let (_, addr) = self.get_id_addr(&id, &tipo);

                let id_addr_exp = self.gen_quads_ver_tam(exp, sz);

                // We store that offset of memory as a constant
                let id_addr_cnst = self.get_id_addr(&addr.to_string(), &Tipo::Int);

                // We store pointer in temp as res
                let ptr_val = self.get_next_ltemp(&Tipo::Int);
                let ptr_tipo = Tipo::Int;
                let ptr_id_addr = self.get_id_addr(&ptr_val, &ptr_tipo);
                self.quads.push(Quadruple::Op(
                    "+".to_string(),
                    id_addr_exp,
                    id_addr_cnst,
                    ptr_id_addr.clone(),
                ));
                let res_val = self.get_next_ltemp(&tipo);
                let res_tipo = tipo.clone();
                let res_id_addr = self.get_id_addr(&res_val, &res_tipo);
                self.quads.push(Quadruple::Deref(ptr_id_addr, res_id_addr));

                // Push var to stack
                self.st_vals.push(res_val);
                self.st_tips.push(res_tipo);
            }
            // TODO
            ast::Variable::Mat(id, exp1, exp2) => {
                let (tipo, sz1, sz2) = self.get_mat_tipo_and_sz_from_id(&id);
                // Get base array position
                let (_, addr) = self.get_id_addr(&id, &tipo);

                let id_addr_exp_1 = self.gen_quads_ver_tam(exp1, sz1);
                let id_addr_exp_2 = self.gen_quads_ver_tam(exp2, sz2);

                // We store second dim size as offset
                let id_addr_off = self.get_id_addr(&sz2.to_string(), &Tipo::Int);
                let ptr_val = self.get_next_ltemp(&Tipo::Int);
                let ptr_tipo = Tipo::Int;
                let ptr_id_addr = self.get_id_addr(&ptr_val, &ptr_tipo);

                self.quads.push(Quadruple::Op(
                    "*".to_string(),
                    id_addr_exp_1,
                    id_addr_off,
                    ptr_id_addr.clone(),
                ));

                self.quads.push(Quadruple::Op(
                    "+".to_string(),
                    ptr_id_addr.clone(),
                    id_addr_exp_2,
                    ptr_id_addr.clone(),
                ));

                // We store that offset of memory as a constant
                let id_addr_cnst = self.get_id_addr(&addr.to_string(), &Tipo::Int);

                self.quads.push(Quadruple::Op(
                    "+".to_string(),
                    ptr_id_addr.clone(),
                    id_addr_cnst,
                    ptr_id_addr.clone(),
                ));
                let res_val = self.get_next_ltemp(&tipo);
                let res_tipo = tipo.clone();
                let res_id_addr = self.get_id_addr(&res_val, &res_tipo);
                self.quads.push(Quadruple::Deref(ptr_id_addr, res_id_addr));

                // Push var to stack
                self.st_vals.push(res_val);
                self.st_tips.push(res_tipo);
            }
        };
        true
    }

    pub fn gen_quads_ver_tam(&mut self, exp: Box<ast::Exp>, sz: i32) -> IdAddr {
        self.eval_exp(exp);

        let id_exp = self.st_vals.pop().unwrap();
        let tipo_exp = self.st_tips.pop().unwrap();
        // Check it is not a type bool as we cant check a dim with float
        if tipo_exp == Tipo::Float {
            self.throw_compile_error(format!("Cannot access array with a Float number"));
        }
        let id_addr_exp = self.get_id_addr(&id_exp, &tipo_exp);
        // Quadruple to verify out of bounds
        self.quads.push(Quadruple::Verify(id_addr_exp.clone(), sz));
        id_addr_exp
    }

    pub fn eval_call(&mut self, call: Box<ast::Call>) -> bool {
        match *call {
            ast::Call::Call(id, exp_vec) => {
                self.quads.push(Quadruple::Era(id.clone()));
                // We get the return type
                // of the function to the expression
                // to check semantics are ok
                let fn_tipo: Tipo = self.get_fn_tipo_from_id(&id);
                let params = self.dir_func.get(&id).unwrap().params.clone();

                if exp_vec.len() != params.len() {
                    self.throw_compile_error(format!(
                        "Function \"{}\" expected {} parameters, got {}",
                        &id,
                        params.len(),
                        exp_vec.len()
                    ));
                }

                for (idx, exp) in exp_vec.into_iter().enumerate() {
                    self.eval_exp(exp);
                    let val = self.st_vals.pop().unwrap();
                    let tipo = self.st_tips.pop().unwrap();
                    // Makee sure param is of expected type or
                    // can be casted
                    self.get_result_tipo(&params[idx], &tipo, "Param");
                    // Gen param quad
                    let id_addr = self.get_id_addr(&val, &tipo);
                    self.quads.push(Quadruple::Parameter(id_addr, idx as i32));
                }
                // Generate GoSub call
                let goto_pos = self.dir_func.get(&id).unwrap().pos_init;
                self.quads.push(Quadruple::GoSub(id.clone(), goto_pos));
                // Get Result from Function if
                // not Void with an assignment
                if fn_tipo != Tipo::Void {
                    // We assign the returned value
                    // stored in global temp depending
                    // on type
                    let id_addr_ret = (
                        "Ret".to_string(),
                        self.vir_mem_alloc.get_gtemp_addr(&fn_tipo),
                    );
                    let res_id = self.get_next_ltemp(&fn_tipo);
                    let res_id_addr = self.get_id_addr(&res_id, &fn_tipo);
                    self.quads
                        .push(Quadruple::Assign("=".to_string(), id_addr_ret, res_id_addr));
                    // Push to stack
                    self.st_vals.push(res_id);
                    self.st_tips.push(fn_tipo.clone());
                } else {
                    // Void function pushed
                    // to detect error if needed
                    self.st_vals.push("VoidResult".to_string());
                    self.st_tips.push(Tipo::Void);
                }
            }
        };
        true
    }

    pub fn eval_ciclew(&mut self, ciclew: Box<ast::Ciclew>) -> bool {
        match *ciclew {
            ast::Ciclew::While(exp, block) => {
                let pos_pending_goto = self.quads.len();

                self.eval_exp(exp);

                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                let id_addr = self.get_id_addr(&id, &tip);
                self.check_tipo_can_eval_as_bool(&tip);
                let pos_pending_gotof = self.quads.len();
                self.quads.push(Quadruple::Temp());

                self.eval_block(block);

                self.quads.push(Quadruple::GoTo(pos_pending_goto as i32));

                self.quads.insert(
                    pos_pending_gotof,
                    Quadruple::GoToF(id_addr, self.quads.len() as i32),
                );
                self.quads.remove(pos_pending_gotof + 1);
            }
        };
        true
    }

    pub fn eval_ciclef(&mut self, ciclef: Box<ast::Ciclef>) -> bool {
        match *ciclef {
            ast::Ciclef::For(exp, assignment, block) => {
                let pos_pending_goto = self.quads.len();

                self.eval_exp(exp);

                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                let id_addr = self.get_id_addr(&id, &tip);
                self.check_tipo_can_eval_as_bool(&tip);
                let pos_pending_gotof = self.quads.len();
                self.quads.push(Quadruple::Temp());

                self.eval_block(block);
                self.eval_assignment(assignment);

                self.quads.push(Quadruple::GoTo(pos_pending_goto as i32));

                self.quads.insert(
                    pos_pending_gotof,
                    Quadruple::GoToF(id_addr, self.quads.len() as i32),
                );
                self.quads.remove(pos_pending_gotof + 1);
            }
        };
        true
    }

    pub fn eval_cond(&mut self, cond: Box<ast::Cond>) -> bool {
        match *cond {
            ast::Cond::If(exp, block) => {
                self.eval_exp(exp);

                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                let id_addr = self.get_id_addr(&id, &tip);
                self.check_tipo_can_eval_as_bool(&tip);
                let pos_pending_if = self.quads.len();
                self.quads.push(Quadruple::Temp());

                self.eval_block(block);

                self.quads.insert(
                    pos_pending_if,
                    Quadruple::GoToF(id_addr, self.quads.len() as i32),
                );
                self.quads.remove(pos_pending_if + 1);
            }
            ast::Cond::IfElse(exp, block_if, block_else) => {
                self.eval_exp(exp);

                let id = self.st_vals.pop().unwrap();
                let tip = self.st_tips.pop().unwrap();
                let id_addr = self.get_id_addr(&id, &tip);
                self.check_tipo_can_eval_as_bool(&tip);
                let pos_pending_f = self.quads.len();
                self.quads.push(Quadruple::Temp());

                self.eval_block(block_if);

                let pos_pending_t = self.quads.len();
                self.quads.push(Quadruple::Temp());
                self.quads.insert(
                    pos_pending_f,
                    Quadruple::GoToF(id_addr, self.quads.len() as i32),
                );
                self.quads.remove(pos_pending_f + 1);

                self.eval_block(block_else);

                self.quads
                    .insert(pos_pending_t, Quadruple::GoTo(self.quads.len() as i32));
                self.quads.remove(pos_pending_t + 1);
            }
        };
        true
    }

    pub fn eval_return(&mut self, ret: Box<ast::Return>) -> bool {
        match *ret {
            ast::Return::Return(exp) => {
                // Check if Void function
                if self.curr_fn_tipo == Tipo::Void {
                    self.throw_compile_error(format!("Cannot call \"Return\" in a Void Function"));
                }
                // Push operator
                self.st_ops.push("Return".to_string());
                // Solve exp
                self.eval_exp(exp);

                assert!(self.st_ops.last().unwrap() == &"Return".to_string());
                self.st_ops.pop();
                let rt_val: String = self.st_vals.pop().unwrap();
                let rt_tipo: Tipo = self.st_tips.pop().unwrap();
                let lt_tipo = self.curr_fn_tipo.clone();
                let lt_id_addr = (
                    "Ret".to_string(),
                    self.vir_mem_alloc.get_gtemp_addr(&lt_tipo),
                );
                // Get result type to assure no type mismatch
                self.get_result_tipo(&lt_tipo, &rt_tipo, "Return");
                let rt_id_addr = self.get_id_addr(&rt_val, &lt_tipo);
                self.quads
                    .push(Quadruple::Assign("=".to_string(), rt_id_addr, lt_id_addr));
                self.quads.push(Quadruple::Return());
            }
        };
        true
    }

    pub fn eval_exp(&mut self, exp: Box<ast::Exp>) -> bool {
        match *exp {
            ast::Exp::Texp(texp_vec) => {
                // Flag for first, as we start using
                // "Or" from second gexp
                let mut fst: bool = true;
                for texp in texp_vec {
                    // Push operator if not first
                    if fst == false {
                        self.st_ops.push("Or".to_string());
                    }
                    // Eval texp
                    self.eval_texp(texp);
                    // Solve operator if not firsts
                    if fst == false {
                        self.solve_exp_quadruple("Or".to_string());
                    }
                    fst = false;
                }
            }
        };
        true
    }

    pub fn eval_texp(&mut self, texp: Box<ast::Texp>) -> bool {
        match *texp {
            ast::Texp::Gexp(gexp_vec) => {
                // Flag for first, as we start using
                // "And" from second gexp
                let mut fst: bool = true;
                for gexp in gexp_vec {
                    // Push operator if not first
                    if fst == false {
                        self.st_ops.push("And".to_string());
                    }
                    // Eval gexp
                    self.eval_gexp(gexp);
                    // Solve operator if not firsts
                    if fst == false {
                        self.solve_exp_quadruple("And".to_string());
                    }
                    fst = false;
                }
            }
        };
        true
    }

    pub fn eval_gexp(&mut self, gexp: Box<ast::Gexp>) -> bool {
        match *gexp {
            ast::Gexp::Mexp(mexp) => {
                self.eval_mexp(mexp);
            }
            ast::Gexp::Comp(mexp1, comp, mexp2) => {
                self.eval_mexp(mexp1);
                self.st_ops.push(self.ast_comp_to_string(&comp));
                self.eval_mexp(mexp2);
                self.solve_exp_quadruple(self.ast_comp_to_string(&comp));
            }
        };
        true
    }

    pub fn eval_mexp(&mut self, mexp: Box<ast::Mexp>) -> bool {
        match *mexp {
            ast::Mexp::Term(term) => {
                self.eval_term(term);
            }
            ast::Mexp::Sum(mexp, term) => {
                self.eval_mexp(mexp);
                self.st_ops.push("+".to_string());
                self.eval_term(term);
                self.solve_exp_quadruple("+".to_string());
            }
            ast::Mexp::Sub(mexp, term) => {
                self.eval_mexp(mexp);
                self.st_ops.push("-".to_string());
                self.eval_term(term);
                self.solve_exp_quadruple("-".to_string());
            }
        };
        true
    }

    pub fn eval_term(&mut self, term: Box<ast::Term>) -> bool {
        match *term {
            ast::Term::Fact(fact) => {
                self.eval_fact(fact);
            }
            ast::Term::Mul(term, fact) => {
                self.eval_term(term);
                self.st_ops.push("*".to_string());
                self.eval_fact(fact);
                self.solve_exp_quadruple("*".to_string());
            }
            ast::Term::Div(term, fact) => {
                self.eval_term(term);
                self.st_ops.push("/".to_string());
                self.eval_fact(fact);
                self.solve_exp_quadruple("/".to_string());
            }
        };
        true
    }

    pub fn eval_fact(&mut self, fact: Box<ast::Fact>) -> bool {
        match *fact {
            ast::Fact::Parentheses(exp) => {
                // We dont need to push anythin to the
                // stacks to keep us from
                // doing unvalid stuff
                // as the precedence in
                // elements solves it alone
                self.eval_exp(exp);
            }
            ast::Fact::Int(num) => {
                self.st_vals.push(num.to_string());
                self.st_tips.push(Tipo::Int);
            }
            ast::Fact::Float(num) => {
                self.st_vals.push(num.to_string());
                self.st_tips.push(Tipo::Float);
            }
            ast::Fact::Bool(num) => {
                self.st_vals.push(if num == true {
                    "True".to_string()
                } else {
                    "False".to_string()
                });
                self.st_tips.push(Tipo::Bool);
            }
            ast::Fact::Call(call) => {
                self.eval_call(call);
            }
            ast::Fact::Variable(var) => {
                self.eval_variable(var);
            }
        };
        true
    }

    pub fn check_multiple_dec_var(&self, id: &String, vars: &DirVar) {
        if let Some(_) = vars.get(id) {
            self.throw_compile_error(format!(
                "Multiple variable declaration: \"{}\" was declared multiple times",
                id,
            ));
        }
    }

    pub fn check_multiple_dec_fns(&self, id: &String) {
        if let Some(_) = self.dir_func.get(id) {
            self.throw_compile_error(format!(
                "Multiple function declaration: \"{}\" was declared multiple times",
                id
            ));
        }
    }

    pub fn solve_exp_quadruple(&mut self, op: String) {
        assert!(self.st_ops.last().unwrap() == &op);
        let rt_val: String = self.st_vals.pop().unwrap();
        let lt_val: String = self.st_vals.pop().unwrap();
        let rt_tipo: Tipo = self.st_tips.pop().unwrap();
        let lt_tipo: Tipo = self.st_tips.pop().unwrap();
        self.st_ops.pop();
        let res_tipo = self.get_result_tipo(&lt_tipo, &rt_tipo, &op);
        let res_id = self.get_next_ltemp(&res_tipo);
        let lt_id_addr = self.get_id_addr(&lt_val, &lt_tipo);
        let rt_id_addr = self.get_id_addr(&rt_val, &rt_tipo);
        let res_id_addr = self.get_id_addr(&res_id, &res_tipo);
        self.quads
            .push(Quadruple::Op(op, lt_id_addr, rt_id_addr, res_id_addr));
        self.st_vals.push(res_id);
        self.st_tips.push(res_tipo)
    }

    pub fn get_result_tipo(&self, left: &Tipo, right: &Tipo, op: &str) -> Tipo {
        let res_tipo = self.sem_cube.table.get(&(
            SC::tipo_to_val(&left),
            SC::tipo_to_val(&right),
            SC::op_to_val(op),
        ));
        if res_tipo == None {
            self.throw_compile_error(format!(
                "Type Mismatch! Operation \"{}\" Between {:?} and {:?} is not allowed",
                op, left, right
            ));
        }
        SC::val_to_tipo(*res_tipo.unwrap())
    }

    pub fn get_next_ltemp(&mut self, tipo: &Tipo) -> String {
        self.next_cnt = self.next_cnt + 1;
        self.add_tmp_var_to_size(&tipo);
        format!("#temp{}", self.next_cnt - 1)
    }

    pub fn get_fn_tipo_from_id(&self, id: &String) -> Tipo {
        if let None = self.dir_func.get(id) {
            self.throw_compile_error(format!("Undeclared function call: \"{}\"", id));
        }
        self.dir_func.get(id).unwrap().tipo.clone()
    }

    pub fn get_arr_tipo_and_sz_from_id(&self, id: &String) -> (Tipo, i32) {
        // We check global scope
        // As arrays are just global
        let vars = &self
            .dir_func
            .get(self.glob_scope.as_ref().unwrap())
            .unwrap()
            .dir_var;
        if let None = vars.get(id) {
            // It is undeclared
            let place: &String = self.glob_scope.as_ref().unwrap();
            self.throw_compile_error(format!("Undeclared array \"{}\" at \"{}\"", id, place));
        }
        let var = vars.get(id).unwrap();
        // Check dims
        self.check_var_dim_is_ok(id, &var.dim, &Dim::Arr(0));
        let sz = match var.dim {
            Dim::Arr(sz) => sz,
            _ => panic!("DEV ERROR: Should be arr"),
        };
        (var.tipo.clone(), sz)
    }

    pub fn get_mat_tipo_and_sz_from_id(&self, id: &String) -> (Tipo, i32, i32) {
        // We check global scope
        // As arrays are just global
        let vars = &self
            .dir_func
            .get(self.glob_scope.as_ref().unwrap())
            .unwrap()
            .dir_var;
        if let None = vars.get(id) {
            // It is undeclared
            let place: &String = self.glob_scope.as_ref().unwrap();
            self.throw_compile_error(format!("Undeclared matrix \"{}\" at \"{}\"", id, place));
        }
        let var = vars.get(id).unwrap();
        // Check dims
        self.check_var_dim_is_ok(id, &var.dim, &Dim::Mat(0, 0));
        let (sz1, sz2) = match var.dim {
            Dim::Mat(sz1, sz2) => (sz1, sz2),
            _ => panic!("DEV ERROR: Should be mat"),
        };
        (var.tipo.clone(), sz1, sz2)
    }

    pub fn get_var_tipo_from_id(&self, id: &String) -> Tipo {
        // First check local scope
        if let Some(loc_scope) = self.loc_scope.as_ref() {
            // Get local var table reference
            let vars = &self.dir_func.get(loc_scope).unwrap().dir_var;
            // Query var
            if let Some(var) = vars.get(id) {
                // Check dims
                self.check_var_dim_is_ok(id, &var.dim, &Dim::Single);
                return var.tipo.clone();
            }
        }
        // If local not found
        // we check global scope
        let vars = &self
            .dir_func
            .get(self.glob_scope.as_ref().unwrap())
            .unwrap()
            .dir_var;
        if let None = vars.get(id) {
            // Not found either locally or globally
            // It is undeclared
            let place: &String = if self.loc_scope == None {
                self.glob_scope.as_ref().unwrap()
            } else {
                self.loc_scope.as_ref().unwrap()
            };
            self.throw_compile_error(format!("Undeclared variable \"{}\" at \"{}\"", id, place));
        }
        let var = vars.get(id).unwrap();
        // Check dims
        self.check_var_dim_is_ok(id, &var.dim, &Dim::Single);
        var.tipo.clone()
    }

    pub fn check_var_dim_is_ok(&self, id: &String, dim: &Dim, dim2: &Dim) {
        // Check dimensions are correct
        let dim_str = self.get_string_from_dim(dim);
        let dim_str2 = self.get_string_from_dim(dim2);
        if dim_str != dim_str2 {
            self.throw_compile_error(format!(
                "\"{}\" has dimensions \"{}\" but was called with dimensions \"{}\"",
                id, dim_str, dim_str2
            ));
        }
    }

    pub fn get_string_from_dim(&self, dim: &Dim) -> String {
        match *dim {
            Dim::Single => format!("Single"),
            Dim::Arr(_) => format!("Array"),
            Dim::Mat(_, _) => format!("Matrix"),
        }
    }

    pub fn check_tipo_can_eval_as_bool(&self, tipo: &Tipo) {
        // Just Int and Bool can eval as Bool
        if tipo != &Tipo::Bool && tipo != &Tipo::Int {
            self.throw_compile_error(format!(
                "Cannot eval a conditional expression. Expected Bool or Int. Got {:?}",
                tipo
            ));
        }
    }

    pub fn ast_comp_to_string(&self, comp: &ast::Comp) -> String {
        match comp {
            ast::Comp::Greater => ">".to_string(),
            ast::Comp::GreaterEq => ">=".to_string(),
            ast::Comp::Smaller => "<".to_string(),
            ast::Comp::SmallerEq => "<=".to_string(),
            ast::Comp::NotEqual => "!=".to_string(),
            ast::Comp::Equal => "==".to_string(),
        }
    }

    pub fn get_id_addr(&mut self, id: &String, tip: &Tipo) -> IdAddr {
        // Local Temp?
        //   Identify with #
        if id.contains("#") {
            return (
                id[1..].to_string(),
                self.vir_mem_alloc.get_ltemp_addr(id, tip),
            );
        }

        // Constant?
        // Numeric (Int, Float, Bool)
        // String Literals
        if id.contains("\"")
            || id.chars().all(|c| !char::is_alphabetic(c))
            || id.chars().nth(0).unwrap() == 'T'
            || id.chars().nth(0).unwrap() == 'F'
        {
            return (id.clone(), self.vir_mem_alloc.get_cnst_addr(&id, tip));
        }

        // Variable?
        // First check local scope
        if let Some(loc_scope) = self.loc_scope.as_ref() {
            // Get local var table reference
            let vars = &self.dir_func.get(loc_scope).unwrap().dir_var;
            // Query var
            if let Some(var) = vars.get(id) {
                return (id.clone(), var.addr);
            }
        }
        // If local not found
        // we check global scope
        // It must exist, as we already checked
        // on eval_variable
        let vars = &self
            .dir_func
            .get(self.glob_scope.as_ref().unwrap())
            .unwrap()
            .dir_var;
        let var = vars.get(id);
        if let None = var {
            panic!("DEV ERROR: Variable with id {} should exist", id);
        }
        let var = var.unwrap();
        (id.clone(), var.addr)
    }

    pub fn add_loc_var_to_size(&mut self, tipo: &Tipo, qnt: i32) {
        match *tipo {
            Tipo::Int => {
                self.curr_fn_size_loc[0] = self.curr_fn_size_loc[0] + qnt;
            }
            Tipo::Float => {
                self.curr_fn_size_loc[1] = self.curr_fn_size_loc[1] + qnt;
            }
            Tipo::Bool => {
                self.curr_fn_size_loc[2] = self.curr_fn_size_loc[2] + qnt;
            }
            _ => {}
        }
    }

    pub fn add_tmp_var_to_size(&mut self, tipo: &Tipo) {
        match *tipo {
            Tipo::Int => {
                self.curr_fn_size_tmp[0] = self.curr_fn_size_tmp[0] + 1;
            }
            Tipo::Float => {
                self.curr_fn_size_tmp[1] = self.curr_fn_size_tmp[1] + 1;
            }
            Tipo::Bool => {
                self.curr_fn_size_tmp[2] = self.curr_fn_size_tmp[2] + 1;
            }
            _ => {}
        }
    }

    pub fn set_fn_size(&mut self, id: &String) {
        let fn_info: &mut FuncInfo = self.dir_func.get_mut(id).unwrap();
        fn_info.size_loc = self.curr_fn_size_loc;
        fn_info.size_tmp = self.curr_fn_size_tmp;
    }

    pub fn reset_fn_params(&mut self) {
        self.vir_mem_alloc.reset_local();
        self.next_cnt = 1;
        self.curr_fn_size_loc = [0, 0, 0];
        self.curr_fn_size_tmp = [0, 0, 0];
    }
}
